package graph
import (
    "strings"
    "errors"
)
// Provides operations to manage the auditLogRoot singleton.
type ConditionalAccessRule int

const (
    ALLAPPS_CONDITIONALACCESSRULE ConditionalAccessRule = iota
    FIRSTPARTYAPPS_CONDITIONALACCESSRULE
    OFFICE365_CONDITIONALACCESSRULE
    APPID_CONDITIONALACCESSRULE
    ACR_CONDITIONALACCESSRULE
    APPFILTER_CONDITIONALACCESSRULE
    ALLUSERS_CONDITIONALACCESSRULE
    GUEST_CONDITIONALACCESSRULE
    GROUPID_CONDITIONALACCESSRULE
    ROLEID_CONDITIONALACCESSRULE
    USERID_CONDITIONALACCESSRULE
    ALLDEVICEPLATFORMS_CONDITIONALACCESSRULE
    DEVICEPLATFORM_CONDITIONALACCESSRULE
    ALLLOCATIONS_CONDITIONALACCESSRULE
    INSIDECORPNET_CONDITIONALACCESSRULE
    ALLTRUSTEDLOCATIONS_CONDITIONALACCESSRULE
    LOCATIONID_CONDITIONALACCESSRULE
    ALLDEVICES_CONDITIONALACCESSRULE
    DEVICEFILTER_CONDITIONALACCESSRULE
    DEVICESTATE_CONDITIONALACCESSRULE
    UNKNOWNFUTUREVALUE_CONDITIONALACCESSRULE
    DEVICEFILTERINCLUDERULENOTMATCHED_CONDITIONALACCESSRULE
    ALLDEVICESTATES_CONDITIONALACCESSRULE
)

func (i ConditionalAccessRule) String() string {
    return []string{"ALLAPPS", "FIRSTPARTYAPPS", "OFFICE365", "APPID", "ACR", "APPFILTER", "ALLUSERS", "GUEST", "GROUPID", "ROLEID", "USERID", "ALLDEVICEPLATFORMS", "DEVICEPLATFORM", "ALLLOCATIONS", "INSIDECORPNET", "ALLTRUSTEDLOCATIONS", "LOCATIONID", "ALLDEVICES", "DEVICEFILTER", "DEVICESTATE", "UNKNOWNFUTUREVALUE", "DEVICEFILTERINCLUDERULENOTMATCHED", "ALLDEVICESTATES"}[i]
}
func ParseConditionalAccessRule(v string) (interface{}, error) {
    result := ALLAPPS_CONDITIONALACCESSRULE
    switch strings.ToUpper(v) {
        case "ALLAPPS":
            result = ALLAPPS_CONDITIONALACCESSRULE
        case "FIRSTPARTYAPPS":
            result = FIRSTPARTYAPPS_CONDITIONALACCESSRULE
        case "OFFICE365":
            result = OFFICE365_CONDITIONALACCESSRULE
        case "APPID":
            result = APPID_CONDITIONALACCESSRULE
        case "ACR":
            result = ACR_CONDITIONALACCESSRULE
        case "APPFILTER":
            result = APPFILTER_CONDITIONALACCESSRULE
        case "ALLUSERS":
            result = ALLUSERS_CONDITIONALACCESSRULE
        case "GUEST":
            result = GUEST_CONDITIONALACCESSRULE
        case "GROUPID":
            result = GROUPID_CONDITIONALACCESSRULE
        case "ROLEID":
            result = ROLEID_CONDITIONALACCESSRULE
        case "USERID":
            result = USERID_CONDITIONALACCESSRULE
        case "ALLDEVICEPLATFORMS":
            result = ALLDEVICEPLATFORMS_CONDITIONALACCESSRULE
        case "DEVICEPLATFORM":
            result = DEVICEPLATFORM_CONDITIONALACCESSRULE
        case "ALLLOCATIONS":
            result = ALLLOCATIONS_CONDITIONALACCESSRULE
        case "INSIDECORPNET":
            result = INSIDECORPNET_CONDITIONALACCESSRULE
        case "ALLTRUSTEDLOCATIONS":
            result = ALLTRUSTEDLOCATIONS_CONDITIONALACCESSRULE
        case "LOCATIONID":
            result = LOCATIONID_CONDITIONALACCESSRULE
        case "ALLDEVICES":
            result = ALLDEVICES_CONDITIONALACCESSRULE
        case "DEVICEFILTER":
            result = DEVICEFILTER_CONDITIONALACCESSRULE
        case "DEVICESTATE":
            result = DEVICESTATE_CONDITIONALACCESSRULE
        case "UNKNOWNFUTUREVALUE":
            result = UNKNOWNFUTUREVALUE_CONDITIONALACCESSRULE
        case "DEVICEFILTERINCLUDERULENOTMATCHED":
            result = DEVICEFILTERINCLUDERULENOTMATCHED_CONDITIONALACCESSRULE
        case "ALLDEVICESTATES":
            result = ALLDEVICESTATES_CONDITIONALACCESSRULE
        default:
            return 0, errors.New("Unknown ConditionalAccessRule value: " + v)
    }
    return &result, nil
}
func SerializeConditionalAccessRule(values []ConditionalAccessRule) []string {
    result := make([]string, len(values))
    for i, v := range values {
        result[i] = v.String()
    }
    return result
}
