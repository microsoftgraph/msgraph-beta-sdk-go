package graph
import (
    "strings"
    "errors"
)
// Provides operations to manage the auditLogRoot singleton.
type ConditionalAccessConditions int

const (
    NONE_CONDITIONALACCESSCONDITIONS ConditionalAccessConditions = iota
    APPLICATION_CONDITIONALACCESSCONDITIONS
    USERS_CONDITIONALACCESSCONDITIONS
    DEVICEPLATFORM_CONDITIONALACCESSCONDITIONS
    LOCATION_CONDITIONALACCESSCONDITIONS
    CLIENTTYPE_CONDITIONALACCESSCONDITIONS
    SIGNINRISK_CONDITIONALACCESSCONDITIONS
    USERRISK_CONDITIONALACCESSCONDITIONS
    TIME_CONDITIONALACCESSCONDITIONS
    DEVICESTATE_CONDITIONALACCESSCONDITIONS
    CLIENT_CONDITIONALACCESSCONDITIONS
    IPADDRESSSEENBYAZUREAD_CONDITIONALACCESSCONDITIONS
    IPADDRESSSEENBYRESOURCEPROVIDER_CONDITIONALACCESSCONDITIONS
    UNKNOWNFUTUREVALUE_CONDITIONALACCESSCONDITIONS
    SERVICEPRINCIPALS_CONDITIONALACCESSCONDITIONS
    SERVICEPRINCIPALRISK_CONDITIONALACCESSCONDITIONS
)

func (i ConditionalAccessConditions) String() string {
    return []string{"NONE", "APPLICATION", "USERS", "DEVICEPLATFORM", "LOCATION", "CLIENTTYPE", "SIGNINRISK", "USERRISK", "TIME", "DEVICESTATE", "CLIENT", "IPADDRESSSEENBYAZUREAD", "IPADDRESSSEENBYRESOURCEPROVIDER", "UNKNOWNFUTUREVALUE", "SERVICEPRINCIPALS", "SERVICEPRINCIPALRISK"}[i]
}
func ParseConditionalAccessConditions(v string) (interface{}, error) {
    result := NONE_CONDITIONALACCESSCONDITIONS
    switch strings.ToUpper(v) {
        case "NONE":
            result = NONE_CONDITIONALACCESSCONDITIONS
        case "APPLICATION":
            result = APPLICATION_CONDITIONALACCESSCONDITIONS
        case "USERS":
            result = USERS_CONDITIONALACCESSCONDITIONS
        case "DEVICEPLATFORM":
            result = DEVICEPLATFORM_CONDITIONALACCESSCONDITIONS
        case "LOCATION":
            result = LOCATION_CONDITIONALACCESSCONDITIONS
        case "CLIENTTYPE":
            result = CLIENTTYPE_CONDITIONALACCESSCONDITIONS
        case "SIGNINRISK":
            result = SIGNINRISK_CONDITIONALACCESSCONDITIONS
        case "USERRISK":
            result = USERRISK_CONDITIONALACCESSCONDITIONS
        case "TIME":
            result = TIME_CONDITIONALACCESSCONDITIONS
        case "DEVICESTATE":
            result = DEVICESTATE_CONDITIONALACCESSCONDITIONS
        case "CLIENT":
            result = CLIENT_CONDITIONALACCESSCONDITIONS
        case "IPADDRESSSEENBYAZUREAD":
            result = IPADDRESSSEENBYAZUREAD_CONDITIONALACCESSCONDITIONS
        case "IPADDRESSSEENBYRESOURCEPROVIDER":
            result = IPADDRESSSEENBYRESOURCEPROVIDER_CONDITIONALACCESSCONDITIONS
        case "UNKNOWNFUTUREVALUE":
            result = UNKNOWNFUTUREVALUE_CONDITIONALACCESSCONDITIONS
        case "SERVICEPRINCIPALS":
            result = SERVICEPRINCIPALS_CONDITIONALACCESSCONDITIONS
        case "SERVICEPRINCIPALRISK":
            result = SERVICEPRINCIPALRISK_CONDITIONALACCESSCONDITIONS
        default:
            return 0, errors.New("Unknown ConditionalAccessConditions value: " + v)
    }
    return &result, nil
}
func SerializeConditionalAccessConditions(values []ConditionalAccessConditions) []string {
    result := make([]string, len(values))
    for i, v := range values {
        result[i] = v.String()
    }
    return result
}
