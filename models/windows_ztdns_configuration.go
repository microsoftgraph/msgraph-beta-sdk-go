// Code generated by Microsoft Kiota - DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package models

import (
    i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91 "github.com/microsoft/kiota-abstractions-go/serialization"
)

// WindowsZtdnsConfiguration windows Zero Trust DNS configuration profile
type WindowsZtdnsConfiguration struct {
    DeviceConfiguration
}
// NewWindowsZtdnsConfiguration instantiates a new WindowsZtdnsConfiguration and sets the default values.
func NewWindowsZtdnsConfiguration()(*WindowsZtdnsConfiguration) {
    m := &WindowsZtdnsConfiguration{
        DeviceConfiguration: *NewDeviceConfiguration(),
    }
    odataTypeValue := "#microsoft.graph.windowsZtdnsConfiguration"
    m.SetOdataType(&odataTypeValue)
    return m
}
// CreateWindowsZtdnsConfigurationFromDiscriminatorValue creates a new instance of the appropriate class based on discriminator value
// returns a Parsable when successful
func CreateWindowsZtdnsConfigurationFromDiscriminatorValue(parseNode i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode)(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable, error) {
    return NewWindowsZtdnsConfiguration(), nil
}
// GetAuditModeEnabled gets the auditModeEnabled property value. Indicates the audit operational mode. When true, unsecured traffic will be logged but not blocked. When false, unsecured DNS traffic will be blocked unless specifically exempted.
// returns a *bool when successful
func (m *WindowsZtdnsConfiguration) GetAuditModeEnabled()(*bool) {
    val, err := m.GetBackingStore().Get("auditModeEnabled")
    if err != nil {
        panic(err)
    }
    if val != nil {
        return val.(*bool)
    }
    return nil
}
// GetExemptionRules gets the exemptionRules property value. Exemptions to the ZTDNS rules, allowing access to specific addresses or subnets via unsecured lookup. This collection can contain a maximum of 500 elements.
// returns a []WindowsZtdnsExemptionRuleable when successful
func (m *WindowsZtdnsConfiguration) GetExemptionRules()([]WindowsZtdnsExemptionRuleable) {
    val, err := m.GetBackingStore().Get("exemptionRules")
    if err != nil {
        panic(err)
    }
    if val != nil {
        return val.([]WindowsZtdnsExemptionRuleable)
    }
    return nil
}
// GetExtendedKeyUsagesForClientAuthentication gets the extendedKeyUsagesForClientAuthentication property value. Extended key usage definitions for client authentication with secure DNS servers. This collection can contain a maximum of 500 elements.
// returns a []ExtendedKeyUsageable when successful
func (m *WindowsZtdnsConfiguration) GetExtendedKeyUsagesForClientAuthentication()([]ExtendedKeyUsageable) {
    val, err := m.GetBackingStore().Get("extendedKeyUsagesForClientAuthentication")
    if err != nil {
        panic(err)
    }
    if val != nil {
        return val.([]ExtendedKeyUsageable)
    }
    return nil
}
// GetFieldDeserializers the deserialization information for the current model
// returns a map[string]func(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode)(error) when successful
func (m *WindowsZtdnsConfiguration) GetFieldDeserializers()(map[string]func(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode)(error)) {
    res := m.DeviceConfiguration.GetFieldDeserializers()
    res["auditModeEnabled"] = func (n i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode) error {
        val, err := n.GetBoolValue()
        if err != nil {
            return err
        }
        if val != nil {
            m.SetAuditModeEnabled(val)
        }
        return nil
    }
    res["exemptionRules"] = func (n i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode) error {
        val, err := n.GetCollectionOfObjectValues(CreateWindowsZtdnsExemptionRuleFromDiscriminatorValue)
        if err != nil {
            return err
        }
        if val != nil {
            res := make([]WindowsZtdnsExemptionRuleable, len(val))
            for i, v := range val {
                if v != nil {
                    res[i] = v.(WindowsZtdnsExemptionRuleable)
                }
            }
            m.SetExemptionRules(res)
        }
        return nil
    }
    res["extendedKeyUsagesForClientAuthentication"] = func (n i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode) error {
        val, err := n.GetCollectionOfObjectValues(CreateExtendedKeyUsageFromDiscriminatorValue)
        if err != nil {
            return err
        }
        if val != nil {
            res := make([]ExtendedKeyUsageable, len(val))
            for i, v := range val {
                if v != nil {
                    res[i] = v.(ExtendedKeyUsageable)
                }
            }
            m.SetExtendedKeyUsagesForClientAuthentication(res)
        }
        return nil
    }
    res["hostsFileResolutionEnabled"] = func (n i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode) error {
        val, err := n.GetBoolValue()
        if err != nil {
            return err
        }
        if val != nil {
            m.SetHostsFileResolutionEnabled(val)
        }
        return nil
    }
    res["loopbackDnsForwarderEnabled"] = func (n i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode) error {
        val, err := n.GetBoolValue()
        if err != nil {
            return err
        }
        if val != nil {
            m.SetLoopbackDnsForwarderEnabled(val)
        }
        return nil
    }
    res["loopbackTrafficBlocked"] = func (n i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode) error {
        val, err := n.GetBoolValue()
        if err != nil {
            return err
        }
        if val != nil {
            m.SetLoopbackTrafficBlocked(val)
        }
        return nil
    }
    res["maximumConnectionTimeInSeconds"] = func (n i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode) error {
        val, err := n.GetInt32Value()
        if err != nil {
            return err
        }
        if val != nil {
            m.SetMaximumConnectionTimeInSeconds(val)
        }
        return nil
    }
    res["rootCertificatesForClientValidation"] = func (n i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode) error {
        val, err := n.GetCollectionOfObjectValues(CreateWindows81TrustedRootCertificateFromDiscriminatorValue)
        if err != nil {
            return err
        }
        if val != nil {
            res := make([]Windows81TrustedRootCertificateable, len(val))
            for i, v := range val {
                if v != nil {
                    res[i] = v.(Windows81TrustedRootCertificateable)
                }
            }
            m.SetRootCertificatesForClientValidation(res)
        }
        return nil
    }
    res["rootCertificatesForServerValidation"] = func (n i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode) error {
        val, err := n.GetCollectionOfObjectValues(CreateWindows81TrustedRootCertificateFromDiscriminatorValue)
        if err != nil {
            return err
        }
        if val != nil {
            res := make([]Windows81TrustedRootCertificateable, len(val))
            for i, v := range val {
                if v != nil {
                    res[i] = v.(Windows81TrustedRootCertificateable)
                }
            }
            m.SetRootCertificatesForServerValidation(res)
        }
        return nil
    }
    res["secureDnsServers"] = func (n i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode) error {
        val, err := n.GetCollectionOfObjectValues(CreateWindowsZtdnsSecureDnsServerFromDiscriminatorValue)
        if err != nil {
            return err
        }
        if val != nil {
            res := make([]WindowsZtdnsSecureDnsServerable, len(val))
            for i, v := range val {
                if v != nil {
                    res[i] = v.(WindowsZtdnsSecureDnsServerable)
                }
            }
            m.SetSecureDnsServers(res)
        }
        return nil
    }
    return res
}
// GetHostsFileResolutionEnabled gets the hostsFileResolutionEnabled property value. Indicates whether the DNS Client can resolve queries using the hosts file.
// returns a *bool when successful
func (m *WindowsZtdnsConfiguration) GetHostsFileResolutionEnabled()(*bool) {
    val, err := m.GetBackingStore().Get("hostsFileResolutionEnabled")
    if err != nil {
        panic(err)
    }
    if val != nil {
        return val.(*bool)
    }
    return nil
}
// GetLoopbackDnsForwarderEnabled gets the loopbackDnsForwarderEnabled property value. Creates a localhost DNS server for securely forwarding plaintext queries to trusted DNS servers.
// returns a *bool when successful
func (m *WindowsZtdnsConfiguration) GetLoopbackDnsForwarderEnabled()(*bool) {
    val, err := m.GetBackingStore().Get("loopbackDnsForwarderEnabled")
    if err != nil {
        panic(err)
    }
    if val != nil {
        return val.(*bool)
    }
    return nil
}
// GetLoopbackTrafficBlocked gets the loopbackTrafficBlocked property value. Indicates whether traffic to loopback addresses should be blocked.
// returns a *bool when successful
func (m *WindowsZtdnsConfiguration) GetLoopbackTrafficBlocked()(*bool) {
    val, err := m.GetBackingStore().Get("loopbackTrafficBlocked")
    if err != nil {
        panic(err)
    }
    if val != nil {
        return val.(*bool)
    }
    return nil
}
// GetMaximumConnectionTimeInSeconds gets the maximumConnectionTimeInSeconds property value. Maximum time in seconds for which connections to an IP address will be allowed after successful name resolution. Valid values 30 to 604800
// returns a *int32 when successful
func (m *WindowsZtdnsConfiguration) GetMaximumConnectionTimeInSeconds()(*int32) {
    val, err := m.GetBackingStore().Get("maximumConnectionTimeInSeconds")
    if err != nil {
        panic(err)
    }
    if val != nil {
        return val.(*int32)
    }
    return nil
}
// GetRootCertificatesForClientValidation gets the rootCertificatesForClientValidation property value. Root certificates for client authentication. This collection can contain a maximum of 500 elements.
// returns a []Windows81TrustedRootCertificateable when successful
func (m *WindowsZtdnsConfiguration) GetRootCertificatesForClientValidation()([]Windows81TrustedRootCertificateable) {
    val, err := m.GetBackingStore().Get("rootCertificatesForClientValidation")
    if err != nil {
        panic(err)
    }
    if val != nil {
        return val.([]Windows81TrustedRootCertificateable)
    }
    return nil
}
// GetRootCertificatesForServerValidation gets the rootCertificatesForServerValidation property value. Root certificates for server validation. This collection can contain a maximum of 500 elements.
// returns a []Windows81TrustedRootCertificateable when successful
func (m *WindowsZtdnsConfiguration) GetRootCertificatesForServerValidation()([]Windows81TrustedRootCertificateable) {
    val, err := m.GetBackingStore().Get("rootCertificatesForServerValidation")
    if err != nil {
        panic(err)
    }
    if val != nil {
        return val.([]Windows81TrustedRootCertificateable)
    }
    return nil
}
// GetSecureDnsServers gets the secureDnsServers property value. Collection of secure DNS servers used to resolve ZTDNS queries. Must contain at least one item. This collection can contain a maximum of 500 elements.
// returns a []WindowsZtdnsSecureDnsServerable when successful
func (m *WindowsZtdnsConfiguration) GetSecureDnsServers()([]WindowsZtdnsSecureDnsServerable) {
    val, err := m.GetBackingStore().Get("secureDnsServers")
    if err != nil {
        panic(err)
    }
    if val != nil {
        return val.([]WindowsZtdnsSecureDnsServerable)
    }
    return nil
}
// Serialize serializes information the current object
func (m *WindowsZtdnsConfiguration) Serialize(writer i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.SerializationWriter)(error) {
    err := m.DeviceConfiguration.Serialize(writer)
    if err != nil {
        return err
    }
    {
        err = writer.WriteBoolValue("auditModeEnabled", m.GetAuditModeEnabled())
        if err != nil {
            return err
        }
    }
    if m.GetExemptionRules() != nil {
        cast := make([]i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable, len(m.GetExemptionRules()))
        for i, v := range m.GetExemptionRules() {
            if v != nil {
                cast[i] = v.(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable)
            }
        }
        err = writer.WriteCollectionOfObjectValues("exemptionRules", cast)
        if err != nil {
            return err
        }
    }
    if m.GetExtendedKeyUsagesForClientAuthentication() != nil {
        cast := make([]i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable, len(m.GetExtendedKeyUsagesForClientAuthentication()))
        for i, v := range m.GetExtendedKeyUsagesForClientAuthentication() {
            if v != nil {
                cast[i] = v.(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable)
            }
        }
        err = writer.WriteCollectionOfObjectValues("extendedKeyUsagesForClientAuthentication", cast)
        if err != nil {
            return err
        }
    }
    {
        err = writer.WriteBoolValue("hostsFileResolutionEnabled", m.GetHostsFileResolutionEnabled())
        if err != nil {
            return err
        }
    }
    {
        err = writer.WriteBoolValue("loopbackDnsForwarderEnabled", m.GetLoopbackDnsForwarderEnabled())
        if err != nil {
            return err
        }
    }
    {
        err = writer.WriteBoolValue("loopbackTrafficBlocked", m.GetLoopbackTrafficBlocked())
        if err != nil {
            return err
        }
    }
    {
        err = writer.WriteInt32Value("maximumConnectionTimeInSeconds", m.GetMaximumConnectionTimeInSeconds())
        if err != nil {
            return err
        }
    }
    if m.GetRootCertificatesForClientValidation() != nil {
        cast := make([]i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable, len(m.GetRootCertificatesForClientValidation()))
        for i, v := range m.GetRootCertificatesForClientValidation() {
            if v != nil {
                cast[i] = v.(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable)
            }
        }
        err = writer.WriteCollectionOfObjectValues("rootCertificatesForClientValidation", cast)
        if err != nil {
            return err
        }
    }
    if m.GetRootCertificatesForServerValidation() != nil {
        cast := make([]i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable, len(m.GetRootCertificatesForServerValidation()))
        for i, v := range m.GetRootCertificatesForServerValidation() {
            if v != nil {
                cast[i] = v.(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable)
            }
        }
        err = writer.WriteCollectionOfObjectValues("rootCertificatesForServerValidation", cast)
        if err != nil {
            return err
        }
    }
    if m.GetSecureDnsServers() != nil {
        cast := make([]i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable, len(m.GetSecureDnsServers()))
        for i, v := range m.GetSecureDnsServers() {
            if v != nil {
                cast[i] = v.(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable)
            }
        }
        err = writer.WriteCollectionOfObjectValues("secureDnsServers", cast)
        if err != nil {
            return err
        }
    }
    return nil
}
// SetAuditModeEnabled sets the auditModeEnabled property value. Indicates the audit operational mode. When true, unsecured traffic will be logged but not blocked. When false, unsecured DNS traffic will be blocked unless specifically exempted.
func (m *WindowsZtdnsConfiguration) SetAuditModeEnabled(value *bool)() {
    err := m.GetBackingStore().Set("auditModeEnabled", value)
    if err != nil {
        panic(err)
    }
}
// SetExemptionRules sets the exemptionRules property value. Exemptions to the ZTDNS rules, allowing access to specific addresses or subnets via unsecured lookup. This collection can contain a maximum of 500 elements.
func (m *WindowsZtdnsConfiguration) SetExemptionRules(value []WindowsZtdnsExemptionRuleable)() {
    err := m.GetBackingStore().Set("exemptionRules", value)
    if err != nil {
        panic(err)
    }
}
// SetExtendedKeyUsagesForClientAuthentication sets the extendedKeyUsagesForClientAuthentication property value. Extended key usage definitions for client authentication with secure DNS servers. This collection can contain a maximum of 500 elements.
func (m *WindowsZtdnsConfiguration) SetExtendedKeyUsagesForClientAuthentication(value []ExtendedKeyUsageable)() {
    err := m.GetBackingStore().Set("extendedKeyUsagesForClientAuthentication", value)
    if err != nil {
        panic(err)
    }
}
// SetHostsFileResolutionEnabled sets the hostsFileResolutionEnabled property value. Indicates whether the DNS Client can resolve queries using the hosts file.
func (m *WindowsZtdnsConfiguration) SetHostsFileResolutionEnabled(value *bool)() {
    err := m.GetBackingStore().Set("hostsFileResolutionEnabled", value)
    if err != nil {
        panic(err)
    }
}
// SetLoopbackDnsForwarderEnabled sets the loopbackDnsForwarderEnabled property value. Creates a localhost DNS server for securely forwarding plaintext queries to trusted DNS servers.
func (m *WindowsZtdnsConfiguration) SetLoopbackDnsForwarderEnabled(value *bool)() {
    err := m.GetBackingStore().Set("loopbackDnsForwarderEnabled", value)
    if err != nil {
        panic(err)
    }
}
// SetLoopbackTrafficBlocked sets the loopbackTrafficBlocked property value. Indicates whether traffic to loopback addresses should be blocked.
func (m *WindowsZtdnsConfiguration) SetLoopbackTrafficBlocked(value *bool)() {
    err := m.GetBackingStore().Set("loopbackTrafficBlocked", value)
    if err != nil {
        panic(err)
    }
}
// SetMaximumConnectionTimeInSeconds sets the maximumConnectionTimeInSeconds property value. Maximum time in seconds for which connections to an IP address will be allowed after successful name resolution. Valid values 30 to 604800
func (m *WindowsZtdnsConfiguration) SetMaximumConnectionTimeInSeconds(value *int32)() {
    err := m.GetBackingStore().Set("maximumConnectionTimeInSeconds", value)
    if err != nil {
        panic(err)
    }
}
// SetRootCertificatesForClientValidation sets the rootCertificatesForClientValidation property value. Root certificates for client authentication. This collection can contain a maximum of 500 elements.
func (m *WindowsZtdnsConfiguration) SetRootCertificatesForClientValidation(value []Windows81TrustedRootCertificateable)() {
    err := m.GetBackingStore().Set("rootCertificatesForClientValidation", value)
    if err != nil {
        panic(err)
    }
}
// SetRootCertificatesForServerValidation sets the rootCertificatesForServerValidation property value. Root certificates for server validation. This collection can contain a maximum of 500 elements.
func (m *WindowsZtdnsConfiguration) SetRootCertificatesForServerValidation(value []Windows81TrustedRootCertificateable)() {
    err := m.GetBackingStore().Set("rootCertificatesForServerValidation", value)
    if err != nil {
        panic(err)
    }
}
// SetSecureDnsServers sets the secureDnsServers property value. Collection of secure DNS servers used to resolve ZTDNS queries. Must contain at least one item. This collection can contain a maximum of 500 elements.
func (m *WindowsZtdnsConfiguration) SetSecureDnsServers(value []WindowsZtdnsSecureDnsServerable)() {
    err := m.GetBackingStore().Set("secureDnsServers", value)
    if err != nil {
        panic(err)
    }
}
type WindowsZtdnsConfigurationable interface {
    DeviceConfigurationable
    i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable
    GetAuditModeEnabled()(*bool)
    GetExemptionRules()([]WindowsZtdnsExemptionRuleable)
    GetExtendedKeyUsagesForClientAuthentication()([]ExtendedKeyUsageable)
    GetHostsFileResolutionEnabled()(*bool)
    GetLoopbackDnsForwarderEnabled()(*bool)
    GetLoopbackTrafficBlocked()(*bool)
    GetMaximumConnectionTimeInSeconds()(*int32)
    GetRootCertificatesForClientValidation()([]Windows81TrustedRootCertificateable)
    GetRootCertificatesForServerValidation()([]Windows81TrustedRootCertificateable)
    GetSecureDnsServers()([]WindowsZtdnsSecureDnsServerable)
    SetAuditModeEnabled(value *bool)()
    SetExemptionRules(value []WindowsZtdnsExemptionRuleable)()
    SetExtendedKeyUsagesForClientAuthentication(value []ExtendedKeyUsageable)()
    SetHostsFileResolutionEnabled(value *bool)()
    SetLoopbackDnsForwarderEnabled(value *bool)()
    SetLoopbackTrafficBlocked(value *bool)()
    SetMaximumConnectionTimeInSeconds(value *int32)()
    SetRootCertificatesForClientValidation(value []Windows81TrustedRootCertificateable)()
    SetRootCertificatesForServerValidation(value []Windows81TrustedRootCertificateable)()
    SetSecureDnsServers(value []WindowsZtdnsSecureDnsServerable)()
}
