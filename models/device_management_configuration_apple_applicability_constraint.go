// Code generated by Microsoft Kiota - DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package models
import (
    "math"
    "strings"
)
// Indicates the supported channel types for an Apple setting.
type DeviceManagementConfigurationAppleApplicabilityConstraint int

const (
    // Not supported.
    NOTSUPPORTED_DEVICEMANAGEMENTCONFIGURATIONAPPLEAPPLICABILITYCONSTRAINT = 1
    // Available on device channel.
    DEVICECHANNEL_DEVICEMANAGEMENTCONFIGURATIONAPPLEAPPLICABILITYCONSTRAINT = 2
    // Available on user channel.
    USERCHANNEL_DEVICEMANAGEMENTCONFIGURATIONAPPLEAPPLICABILITYCONSTRAINT = 4
    // Requires supervised devices.
    REQUIRESUPERVISED_DEVICEMANAGEMENTCONFIGURATIONAPPLEAPPLICABILITYCONSTRAINT = 8
    // Requires a DEP enrolled macOS device.
    REQUIREDEPENROLLED_DEVICEMANAGEMENTCONFIGURATIONAPPLEAPPLICABILITYCONSTRAINT = 16
    // Requires user-approved enrolled macOS device.
    REQUIREUSERAPPROVED_DEVICEMANAGEMENTCONFIGURATIONAPPLEAPPLICABILITYCONSTRAINT = 32
    // Allowed for user enrolled devices.
    ALLOWUSERENROLLMENT_DEVICEMANAGEMENTCONFIGURATIONAPPLEAPPLICABILITYCONSTRAINT = 64
    // Evolvable enumeration sentinel value. Do not use.
    UNKNOWNFUTUREVALUE_DEVICEMANAGEMENTCONFIGURATIONAPPLEAPPLICABILITYCONSTRAINT = 128
)

func (i DeviceManagementConfigurationAppleApplicabilityConstraint) String() string {
    var values []string
    options := []string{"notSupported", "deviceChannel", "userChannel", "requireSupervised", "requireDepEnrolled", "requireUserApproved", "allowUserEnrollment", "unknownFutureValue"}
    for p := 0; p < 8; p++ {
        mantis := DeviceManagementConfigurationAppleApplicabilityConstraint(int(math.Pow(2, float64(p))))
        if i&mantis == mantis {
            values = append(values, options[p])
        }
    }
    return strings.Join(values, ",")
}
func ParseDeviceManagementConfigurationAppleApplicabilityConstraint(v string) (any, error) {
    var result DeviceManagementConfigurationAppleApplicabilityConstraint
    values := strings.Split(v, ",")
    for _, str := range values {
        switch str {
            case "notSupported":
                result |= NOTSUPPORTED_DEVICEMANAGEMENTCONFIGURATIONAPPLEAPPLICABILITYCONSTRAINT
            case "deviceChannel":
                result |= DEVICECHANNEL_DEVICEMANAGEMENTCONFIGURATIONAPPLEAPPLICABILITYCONSTRAINT
            case "userChannel":
                result |= USERCHANNEL_DEVICEMANAGEMENTCONFIGURATIONAPPLEAPPLICABILITYCONSTRAINT
            case "requireSupervised":
                result |= REQUIRESUPERVISED_DEVICEMANAGEMENTCONFIGURATIONAPPLEAPPLICABILITYCONSTRAINT
            case "requireDepEnrolled":
                result |= REQUIREDEPENROLLED_DEVICEMANAGEMENTCONFIGURATIONAPPLEAPPLICABILITYCONSTRAINT
            case "requireUserApproved":
                result |= REQUIREUSERAPPROVED_DEVICEMANAGEMENTCONFIGURATIONAPPLEAPPLICABILITYCONSTRAINT
            case "allowUserEnrollment":
                result |= ALLOWUSERENROLLMENT_DEVICEMANAGEMENTCONFIGURATIONAPPLEAPPLICABILITYCONSTRAINT
            case "unknownFutureValue":
                result |= UNKNOWNFUTUREVALUE_DEVICEMANAGEMENTCONFIGURATIONAPPLEAPPLICABILITYCONSTRAINT
            default:
                return nil, nil
        }
    }
    return &result, nil
}
func SerializeDeviceManagementConfigurationAppleApplicabilityConstraint(values []DeviceManagementConfigurationAppleApplicabilityConstraint) []string {
    result := make([]string, len(values))
    for i, v := range values {
        result[i] = v.String()
    }
    return result
}
func (i DeviceManagementConfigurationAppleApplicabilityConstraint) isMultiValue() bool {
    return true
}
